"""
Dynamic wrapper for dbt model: {{ model_name }}
Node ID: {{ node_id }}

This is a lightweight wrapper that loads and executes SQL dynamically at runtime.
"""

from pathlib import Path
from typing import Any, List, Optional

from pyspark.sql import DataFrame, SparkSession

from ingen_fab.packages.dbt.runtime.dynamic import DynamicModelLoader, DynamicSQLExecutor


class {{ class_name }}:
    """
    Dynamic wrapper for dbt model: {{ model_name }}

    This class loads SQL statements from JSON files at runtime rather than
    embedding them in the code. This allows for hot-reload capabilities and
    reduces the need for code regeneration when SQL changes.
    """

    def __init__(self, spark_session: SparkSession, dbt_project_path: Optional[Path] = None):
        """
        Initialize the dynamic model wrapper.

        Args:
            spark_session: Active SparkSession instance
            dbt_project_path: Path to dbt project (defaults to {{ default_project_path }})
        """
        self.spark = spark_session
        self.node_id = "{{ node_id }}"
        self.model_name = "{{ model_name }}"

        # Set project path
        if dbt_project_path is None:
            # Use default path relative to this file
            dbt_project_path = Path("{{ default_project_path }}")

        self.project_path = Path(dbt_project_path)

        # Initialize loader and executor
        self.loader = DynamicModelLoader(self.project_path)
        self.executor = DynamicSQLExecutor(spark_session, self.loader)

        # Cache metadata
        self._metadata = None
        self._sql_statements = None

    @property
    def metadata(self) -> dict:
        """Get cached metadata for this model."""
        if self._metadata is None:
            self._metadata = self.loader.get_node_metadata(self.node_id)
        return self._metadata

    @property
    def sql_statements(self) -> List[str]:
        """Get cached SQL statements for this model."""
        if self._sql_statements is None:
            self._sql_statements = self.loader.get_sql_statements(self.node_id)
        return self._sql_statements

    def execute_all(self) -> List[Optional[DataFrame]]:
        """
        Execute all SQL statements for this model.

        Returns:
            List of DataFrame results (may contain None for statements without results)
        """
        print(f"Executing {self.node_id} with {len(self.sql_statements)} statements")
        results = self.executor.execute_node(
            self.node_id,
            execute_python_first=True,
            return_last_result=False
        )
        print(f"âœ“ Successfully executed {self.node_id}")
        return results

    def execute(self) -> Optional[DataFrame]:
        """
        Execute the model and return the last result.

        Returns:
            DataFrame result of the last statement if applicable, None otherwise
        """
        return self.executor.execute_node(
            self.node_id,
            execute_python_first=True,
            return_last_result=True
        )

    def reload(self) -> None:
        """
        Reload SQL statements and metadata from disk.

        This allows hot-reload of SQL changes without restarting.
        """
        self.loader.clear_cache()
        self._metadata = None
        self._sql_statements = None
        print(f"Reloaded {self.node_id} from disk")

    def get_dependencies(self) -> List[str]:
        """
        Get list of nodes this model depends on.

        Returns:
            List of node IDs that this model depends on
        """
        return self.metadata.get("dependencies", [])

    def validate(self) -> dict:
        """
        Validate that this model can be executed.

        Returns:
            Validation result dictionary
        """
        return self.executor.validate_node(self.node_id)

    def __repr__(self) -> str:
        """String representation of the class."""
        return f"<{{ class_name }}(node_id='{self.node_id}', model='{self.model_name}', mode='dynamic')>"