"""
Generated Python class for dbt model: {{ model_name }}
Source: {{ json_file_name }}
Node ID: {{ node_id }}
"""

from typing import Any, List, Optional
from pyspark.sql import DataFrame, SparkSession


class {{ class_name }}:
    """
    Python class for executing dbt model: {{ model_name }}
    Generated from: {{ json_file_name }}
    """

    def __init__(self, spark_session: SparkSession):
        """
        Initialize the {{ class_name }} with a Spark session.
        
        Args:
            spark_session: Active SparkSession instance
        """
        self.spark = spark_session
        self.node_id = "{{ node_id }}"
        self.session_id = "{{ session_id }}"
        self.model_name = "{{ model_name }}"

{% for sql_method in sql_methods %}
    def {{ sql_method.method_name }}(self) -> Optional[DataFrame]:
        """
        Execute SQL statement {{ sql_method.statement_number }} of {{ total_statements }}.
        
        Returns:
            DataFrame result if applicable, None otherwise
        """
        sql = """{{ sql_method.sql_content | replace('"""', '\\"\\"\\"') }}"""
        
        for s in sql.split(';\n'):
            try:
                result = self.spark.sql(s)
                return result
            except Exception as e:
                raise RuntimeError(f"Failed to execute {{ sql_method.method_name }} for {self.model_name}: {e}")

{% endfor %}
{% if has_injected_code %}
    def execute_injected_python(self) -> Optional[Any]:
        """
        Execute injected Python code from models_python directory.
        
        Returns:
            Result of the injected Python code execution
        """
        try:
{{ injected_python_code | indent(12, True) }}
        except Exception as e:
            raise RuntimeError(f"Failed to execute injected Python code for {self.model_name}: {e}")
{% endif %}

    def execute_all(self) -> List[Optional[DataFrame]]:
        """
        Execute all SQL statements in sequence.
        
        Returns:
            List of DataFrame results (may contain None for statements without results)
        """
        results = []
        
{% if has_injected_code %}
        # Execute injected Python code first
        try:
            injected_result = self.execute_injected_python()
            results.append(injected_result)
            print(f"✓ Successfully executed {self.node_id}.execute_injected_python")
        except Exception as e:
            print(f"✗ Failed to execute {self.node_id}.execute_injected_python: {e}")
            raise
        
{% endif %}
{% for sql_method in sql_methods %}
        # Execute statement {{ sql_method.statement_number }}: {{ sql_method.method_name }}
        try:
            result = self.{{ sql_method.method_name }}()
            results.append(result)
            print(f"✓ Successfully executed {self.node_id}.{{ sql_method.method_name }}")
        except Exception as e:
            print(f"✗ Failed to execute {self.node_id}.{{ sql_method.method_name }}: {e}")
            raise
        
{% endfor %}
        return results

    def __repr__(self) -> str:
        """String representation of the class."""
        return f"<{{ class_name }}(node_id='{self.node_id}', model='{self.model_name}')>"